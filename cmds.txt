Ping uses the ECHO_REQUEST from the ICMP protocol to obtain an ECHO_RESPONSE.
Les datagrammes ECHO_REQUEST contiennent un header IP, un header ICMP, une struct timeval
et un nombre arbitraire d'octets pour bourrer (remplir) le paquet

ICMP = Internet Control Message Protocol

		Usefull ICMP Message (in our case)
|----------------------------------------------|
| Type ICMP | Nom du type | Code | Description |
|-----------|-------------|------|-------------|
|     8     |ECHO_REQUEST |   0  | Ping reseau |
|-----------|-------------|------|-------------|
|     3     |Dest unaccess|0 - 15|Message Error|
|-----------|-------------|------|-------------|
|    11     |   Timeout   |0 - 1 |   Timeout   |
|----------------------------------------------|

Note :
	Type 3 Code 2/3 can close a TCP connexion

Header de l'ICMP:
Octets | Description
  0-7  |    Type
  8-15 |    Code
 16-31 | Somme de controle
 32-64 | Information du header

Code precise quel device (0: destination, 1: hote, 3: port)
Somme de controle garanti l'exactitude des informations. Se fait de la meme maniere que
	autres protocols (IP, UDP, TCP)
Les donnes ICMP sont structurees differemment suivant le type de l'instance de declenchement

ping -v => Sortie verbeuse
ping -V => Afficher le numero de version

In the main sending loop:
	1/ Set ttl option to a value in TTL socket => limit num of hops packet can make
	2/ Set the timeout of recv function. If not set => loop infinite pending loop
	3/ Fill up the icmp packet:
	   |---	a/ Set packet type to ICMP_ECHO
	   |---	b/ set id to pid of process
	   |---	c/ Fill msg part randomly
	   |---	d/ Calculate checksun and fill checksum field
	   |---	e/ Send packet
	   |---	f/ Wait for the answer and check for the type in header

OSI model => Open systems Intercommunication
Norme de communication de tous les systemes informatique en reseau.
Modele de communication, decrivant les fonctionnalites de communication et l'organisation.

Modele fonctionnant en couche:
					| Application
	Couche haute	| Presentation
					| Session
					| Transport
---------------------------
					| Reseau
  Couche materielle | Liaison
					| Physique

Description:
	Physique: Effective transmission of signals. Service limited to emission and reception 
	|	of a bit or serie of continuous bits.
	Liaison: Gere les communication de deux machines directement connectees entre elles.
	Reseau: communications proche en proche. Routage et addressage des paquets.
	Transport: Gere communications de bout en bout entre processus.
	Session: Synchonise les ehcange et transactions. Ouvre et ferme les sessions.
	Presentation: Code les donnees applicatives( conversion donnes applicatives => chaines d'octets transmises).
	Application: Points d'acces aux services reseaux. Pas de service propre.


Le protocole ICMP = couche reseau (3) du model OSI. (Comme le protocole IP).
IP ne permet pas l'envoi de messages d'erreurs, on lui associe donc ICMP pour controler les controler.
L' ICMP fait partie d'un paquet IP.

Raw sockets:
	Used to receive and send packets, bypassignt the normal TCP/IP.
	The packets are directly transmitted to socket interface from Ethernet Layer.
	Stream socket only exchange data: no headers, no IP or MAC address.
	Raw sockets receives unextracted packets, no need to provide port or IP address 
		to it (unlike case stramd or datagram sockets).

DNS:
	Domain Name system: Gives an IP address a domain name to be more friendly.
	In some cases it is usefull to reverse the domain name, more precisely the host name: Reverse DNS lookup.
	rDNS: request that reverses the domain and host name of an IP address. Need the internet 
	|	address to have a PTR-record that points the name and permits a invert request in the DNS.
	How it works:
		search in the whole DNS for the IP address would be too long
		So the rDNS is configured with a proper domain in in-addr.arpa(IPV4) with 3 sub-domains. Permits resolving the
		|	address with max 3 steps.
		- sub-domain rDNS 1: first component of the IP address
		- sub-domain rDNS 2: second
		- sub-domain rDNS 3: third
		Each component of the IP address is inverted. 192.0.2.x => 2.0.192.in-addr.arpa


Usefull C functions:
	gethostbyname() => Converts human readable website and retuens a structure type hostent containing IP 
	|	address in binary dot form and address type.
	Raw socket => socket(, RAW_SOCKET, );


Ping output:
	Pinging google.com [142.251.214.142] with 32 bytes of data:
	Reply from 142.251.214.142: bytes=32 time=15ms TTL=58
	Reply from 142.251.214.142: bytes=32 time=13ms TTL=58
	Reply from 142.251.214.142: bytes=32 time=15ms TTL=58
	Reply from 142.251.214.142: bytes=32 time=15ms TTL=58

	Ping statistics for 142.251.214.142:
		Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
	Approximate round trip times in milli-seconds:
		Minimum = 13ms, Maximum = 15ms, Average = 14ms

	Pinging => State the host. Shows domain name and IP address.
	Reply from => followed by IP address IF success.
					ELSE if not received within a certain timeframe: Request timed out.
	bytes => size of the ICMP packet received. generally same size than the one sent.
	time => Round-Time Trip (RTT). Time for the ICMP packet to reach and return to the source.
	TTL => Time to live. Each router decrease the ttl by one. The base value is 255.
			The value return is the starting value - number router.
	ping statistics => Summary. Total number of packets sent, received and lost.
	Approximate RTT => minimum, average, maximum RTT 



Checksum:
	Algorithm:
		Also called Longitudinal Redundancy Check: the data must be devided insto transmission blocks, to which additional
		check data is added.
		Pseudo code:
			lrc := 0
			for each byte b in the buffer do
				lrc := (lrc + b) and 0xFF
			lrc := (((lrc XOR 0xFF) + 1) and 0xFF)


Size of Ping packet:
	The default ping size can vary depending on the operating system:
		Windows: The default ping size is 32 bytes.
		Linux and macOS: The default ping size is 64 bytes.
	You can always specify a different packet size using the -l option in Windows or the -s option in Linux/macOS when using the ping command.


Ping core functions:
	ssize_t sendto(int socket, const void *mess, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t dest_len);
	ssize_t recvfrom(int socket, void *restrict buffer, size_t length, int flags, struct sockaddr *restrict address, socklen_t *restrict len);

	socket = socket defined by socket();
	const void *mess = le packet struct packet (hdr + mess)
	flags = 0

	buffer = char[];
	flags = 0
	address = NULL ptr || ptr to a struct sockaddr where soending addr will be stored